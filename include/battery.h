/* Auto-generated by cbindgen. */

#ifndef BATTERY_H
#define BATTERY_H

#pragma once

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#define WIDTH 16

#define HASH_SIZE 8

#define TFHE_TRLWE_N (1 << 10)

#define Q (1 << 50)

#define ERR_B 250

#define BATTERY_OK 0

#define BATTERY_ERR_NULL -1

#define BATTERY_ERR_BADLEN -2

#define BATTERY_ERR_SEEDLEN -6

#define BATTERY_ERR_INPUT -8

#define BATTERY_ERR_BUFSZ -10

#define BATTERY_SEED_LEN 32

#define BATTERY_NONCE_LEN 32

#define BATTERY_API_VERSION 1

void rust_eh_personality(void);

uint32_t battery_api_version(void);

/**
 * Encrypt an arbitrary byte string by encoding its bits LSB-first into a TRLWE plaintext
 * and encrypting it with the TFHE public key. The number of encoded bits is `bytes_len * 8`.
 * Fails if `bytes_len * 8 > TFHE_TRLWE_N`.
 */
int32_t tfhe_pk_encrypt(const uint8_t *pk,
                        size_t pk_len,
                        const uint8_t *bytes,
                        size_t bytes_len,
                        const uint8_t *seed32,
                        size_t seed_len,
                        uint8_t *ct_out,
                        size_t ct_out_len,
                        size_t *out_written);

/**
 * Compute the parent hash from the two secret leaves using the same Poseidon2 parameters
 * and orientation used in the Merkle tree: parent = H(leaf || sibling) with selector=0.
 * Inputs:
 * - `secret16_u32`: two concatenated leaves as 16 u32 words.
 * Outputs:
 * - `parent8_u32_out`: 8 u32 words with the parent field elements.
 */
int32_t zkp_parent_from_secret(const uint32_t *secret16_u32, uint32_t *parent8_u32_out);

/**
 * Encrypt bytes and return raw TRLWE ciphertext coefficients (no serialization).
 * a_out and b_out must each point to arrays of length TFHE_TRLWE_N.
 */
int32_t tfhe_pk_encrypt_raw(const uint8_t *pk,
                            size_t pk_len,
                            const uint8_t *bytes,
                            size_t bytes_len,
                            const uint8_t *seed32,
                            size_t seed_len,
                            uint64_t *a_out,
                            uint64_t *b_out);

/**
 * Generate a Merkle-path ZK proof. The device provides both secret leaves,
 * and the opaque args contain the parent→root path supplied by the server.
 * Inputs:
 * - `secret16_u32`: two concatenated leaves as 16 `u32` words: [leaf(8) | sibling(8)]
 * - `args`/`args_len`: postcard-serialized OpaqueMerklePathArgs (parent→root)
 * - `nonce32` (len=`BATTERY_NONCE_LEN`)
 * Outputs:
 * - `proof_out`/`proof_out_len`: caller-provided buffer for postcard-serialized bundle:
 *   (proof, public_values) where public_values = [root(8) | nonce_field(8) | hash(leaf||nonce)(8)].
 * - `out_proof_written`: number of bytes written. If too small, returns `BATTERY_ERR_BUFSZ`.
 *
 * Serialization: postcard 1.x (stable).
 */
int32_t zkp_generate_proof(const uint32_t *secret16_u32,
                           const uint8_t *args,
                           size_t args_len,
                           const uint8_t *nonce32,
                           uint8_t *proof_out,
                           size_t proof_out_len,
                           size_t *out_proof_written);

/**
 * Serialization: postcard 1.x (stable).
 */
int32_t tfhe_pack_public_key(const uint64_t *pk_a,
                             const uint64_t *pk_b,
                             uint8_t *out,
                             size_t out_len,
                             size_t *out_written);

/**
 * Pack Merkle path arguments into a postcard-serialized opaque buffer.
 * Serialization: postcard 1.x (stable).
 */
int32_t zkp_pack_args(const uint32_t *neighbors8_by_level_u32,
                      const uint8_t *sides_bitflags,
                      size_t levels,
                      uint8_t *out,
                      size_t out_len,
                      size_t *out_written);

#endif  /* BATTERY_H */
