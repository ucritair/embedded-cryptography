/* Auto-generated by cbindgen. */

#ifndef BATTERY_H
#define BATTERY_H

#pragma once

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#define WIDTH 16

#define HASH_SIZE 8

#define TFHE_TRLWE_N 1024

#define BATTERY_OK 0

#define BATTERY_ERR_NULL -1

#define BATTERY_ERR_BADLEN -2

#define BATTERY_ERR_SEEDLEN -6

#define BATTERY_ERR_INPUT -8

#define BATTERY_ERR_BUFSZ -10

#define BATTERY_SEED_LEN 32

#define BATTERY_NONCE_LEN 32

#define AES_KEY_LEN 16

#define AES_IV_LEN 16

#define BATTERY_API_VERSION 1

void rust_eh_personality(void);

uint32_t griffon_heap_used(void);

uint32_t griffon_heap_free(void);

void griffon_heap_init(size_t heap_start_addr, size_t heap_size);

uint32_t battery_api_version(void);

/**
 * DEPRECATED: use `tfhe_pk_encrypt` for arbitrary-length byte payloads.
 * This wrapper now forwards to `tfhe_pk_encrypt` with `bytes_len = AES_KEY_LEN`.
 * Inputs/outputs are unchanged and remain opaque postcard buffers.
 */
int32_t tfhe_pk_encrypt_aes_key(const uint8_t *pk,
                                size_t pk_len,
                                const uint8_t *aes_key16,
                                const uint8_t *seed32,
                                size_t seed_len,
                                uint8_t *ct_out,
                                size_t ct_out_len,
                                size_t *out_written);

/**
 * Encrypt an arbitrary byte string by encoding its bits LSB-first into a TRLWE plaintext
 * and encrypting it with the TFHE public key. The number of encoded bits is `bytes_len * 8`.
 * Fails if `bytes_len * 8 > TFHE_TRLWE_N`.
 */
int32_t tfhe_pk_encrypt(const uint8_t *pk,
                        size_t pk_len,
                        const uint8_t *bytes,
                        size_t bytes_len,
                        const uint8_t *seed32,
                        size_t seed_len,
                        uint8_t *ct_out,
                        size_t ct_out_len,
                        size_t *out_written);

/**
 * Encrypt bytes and return raw TRLWE ciphertext coefficients (no serialization).
 * a_out and b_out must each point to arrays of length TFHE_TRLWE_N.
 */
int32_t tfhe_pk_encrypt_raw(const uint8_t *pk,
                            size_t pk_len,
                            const uint8_t *bytes,
                            size_t bytes_len,
                            const uint8_t *seed32,
                            size_t seed_len,
                            uint64_t *a_out,
                            uint64_t *b_out);

/**
 * Generate a Merkle-path ZK proof using a single opaque serialized argument, with a separate nonce.
 * Inputs:
 * - `args`/`args_len`: postcard-serialized OpaqueMerklePathArgs
 * - `nonce32` (len=`BATTERY_NONCE_LEN`)
 * Outputs:
 * - `proof_out`/`proof_out_len`: caller-provided buffer for postcard-serialized bundle:
 *   (proof, public_values) where public_values = [root(8) | nonce_field(8) | hash(leaf||nonce)(8)].
 * - `out_proof_written`: number of bytes written. If too small, returns `BATTERY_ERR_BUFSZ`.
 * Serialization: postcard 1.x (stable).
 */
int32_t zkp_generate_proof(const uint8_t *args,
                           size_t args_len,
                           const uint8_t *nonce32,
                           uint8_t *proof_out,
                           size_t proof_out_len,
                           size_t *out_proof_written);

int32_t aes_ctr_encrypt(uint8_t *buf,
                        size_t len,
                        const uint8_t *key16,
                        size_t key_len,
                        const uint8_t *iv16,
                        size_t iv_len);

/**
 * Pack a TFHE public key from `u64[N]` arrays into a postcard-serialized opaque buffer.
 * Serialization: postcard 1.x (stable).
 */
int32_t tfhe_pack_public_key(const uint64_t *pk_a,
                             const uint64_t *pk_b,
                             uint8_t *out,
                             size_t out_len,
                             size_t *out_written);

/**
 * Pack Merkle path arguments into a postcard-serialized opaque buffer.
 * Serialization: postcard 1.x (stable).
 */
int32_t zkp_pack_args(const uint32_t *leaf8_u32,
                      const uint32_t *neighbors8_by_level_u32,
                      const uint8_t *sides_bitflags,
                      size_t levels,
                      uint8_t *out,
                      size_t out_len,
                      size_t *out_written);

#endif  /* BATTERY_H */
